---
title: "5. Pengantar Unit Testing"
date: 2025-10-30
categories: [Software Testing & QA]
tags: [Testing, QA]
---

# Pengantar Unit Testing

Unit testing merupakan salah satu kategori pengujian perangkat lunak yang berfokus pada evaluasi komponen atau **unit terkecil** dalam sebuah sistem, seperti *function*, *method*, atau *class* individual. Dalam hierarki pengujian (*Test Pyramid*), unit testing berada di level paling dasar, mendahului *Integration Test* dan *End-to-End (E2E) Test*.

Pengujian ini umumnya adalah yang pertama kali dieksekusi oleh pengembang. Karena beroperasi pada komponen individual tanpa perlu interaksi dengan seluruh sistem, unit testing dikenal sebagai metode yang **paling cepat** dan **paling efisien** dari segi biaya eksekusi.

Sebagai ilustrasi, bayangkan Anda merakit sebuah mobil. Unit testing setara dengan menginspeksi setiap komponen secara terpisah—rem, mesin, dan ban—sebelum komponen tersebut dipasang. Jika setiap bagian lolos uji, keyakinan terhadap kualitas mobil rakitan secara keseluruhan akan meningkat.

---

## Mengapa Unit Testing Sangat Penting?

Menerapkan unit testing secara konsisten adalah kunci untuk menjaga kualitas, keandalan, dan kemudahan pemeliharaan (*maintainability*) kode.

* **Deteksi Cacat Dini:** Memungkinkan identifikasi kesalahan logika bisnis atau masalah sintaks pada fase awal pengembangan. Memperbaiki *bug* di tingkat unit jauh lebih murah daripada menemukannya setelah komponen-komponen terintegrasi.
* **Keamanan saat Refactoring:** Ketika pengembang perlu merestrukturisasi atau membersihkan kode (*refactoring*), *suite* unit test yang ada berfungsi sebagai jaring pengaman. Ini memastikan bahwa perubahan yang dilakukan tidak merusak fungsionalitas yang sudah bekerja.
* **Meningkatkan Kualitas Desain Kode:** Mendorong pengembang untuk menulis kode yang *testable* (mudah diuji). Kode yang *testable* cenderung lebih rapi, modular (*low-coupling*), dan mematuhi *Single Responsibility Principle*.
* **Dokumentasi Fungsional:** Unit test secara efektif bertindak sebagai dokumentasi teknis yang "hidup". Ia mendemonstrasikan bagaimana sebuah fungsi seharusnya digunakan dan hasil apa yang diharapkan, sangat membantu pengembang lain.
* **Efisiensi Biaya dan Waktu:** Memperbaiki kesalahan di level unit menghemat waktu dan sumber daya yang besar dibandingkan harus menelusuri *bug* kompleks di lingkungan produksi.

---

## Pola Dasar Unit Testing: Arrange, Act, Assert (AAA)

Untuk memastikan setiap unit test mudah dibaca dan dipahami, pengembang secara luas mengadopsi pola **Arrange-Act-Assert (AAA)**, membagi tes menjadi tiga langkah terpisah:

1.  **Arrange (Atur):** Menyiapkan semua prasyarat dan data yang dibutuhkan untuk tes, termasuk inisialisasi objek, variabel, dan *mock* dependensi.
2.  **Act (Bertindak):** Menjalankan *function* atau *method* spesifik yang menjadi target pengujian.
3.  **Assert (Pastikan):** Memverifikasi hasil yang diperoleh dari langkah *Act* sesuai dengan hasil yang diharapkan (*expectation*).

---

## Framework Unit Testing Populer

Penggunaan *framework* khusus mempermudah penulisan dan eksekusi tes. Pilihan *framework* bergantung pada bahasa pemrograman proyek:

| Framework | Bahasa | Keunggulan Utama |
| :--- | :--- | :--- |
| **JUnit 5** | Java | Standar *de facto* di ekosistem Java (termasuk Kotlin). Integrasi penuh dengan *tools* Java dan struktur berbasis anotasi (`@Test`). |
| **Jest** | JavaScript | Sangat populer di proyek React, Node.js, dan TypeScript (dibuat oleh Meta). Dikenal karena konfigurasi yang minimal (*zero-config*) dan fitur canggih (*snapshot testing*). |
| **Pytest** | Python | Sederhana, mudah dibaca, dan kuat untuk berbagai jenis proyek Python. Sintaks yang simpel, *fixtures* yang kuat, dan laporan *error* yang sangat detail. |

---

## Konsep Kunci dan Karakteristik dalam Unit Testing

### Karakteristik Kode yang Testable

Agar unit testing efektif, kode sumber harus ditulis dengan mempertimbangkan kemudahan pengujian:

* **Low-Coupling:** Ketergantungan antar komponen (fungsi/kelas) harus minimal, memungkinkan pengujian dilakukan secara independen.
* **Pure Function:** Fungsi ideal adalah fungsi murni—tidak memiliki efek samping (*side effects*) dan hanya bergantung pada input yang diberikan.
* **Pemisahan Tanggung Jawab:** Logika bisnis harus dipisahkan dari kode presentasi (UI) agar logika dapat diuji secara terisolasi.
* **Kesederhanaan:** Kode dengan kompleksitas yang rendah (*low cyclomatic complexity*) lebih mudah diuji karena jalur eksekusinya terbatas.

### Test Driven Development (TDD)

TDD adalah sebuah metodologi di mana tes ditulis **sebelum** kode implementasi fungsionalitas yang sesungguhnya. Prosesnya mengikuti siklus:

1.  **Red (Merah):** Tulis tes yang mendefinisikan fungsionalitas baru. Jalankan, dan pastikan tes tersebut **gagal**.
2.  **Green (Hijau):** Tulis kode implementasi paling sederhana yang dibutuhkan agar tes yang gagal tersebut **berhasil lulus**.
3.  **Refactor (Refaktor):** Bersihkan kode implementasi tanpa mengubah perilakunya (tes harus tetap lulus).

Pendekatan ini menjamin cakupan tes (*test coverage*) yang tinggi dan memperjelas persyaratan fungsionalitas sejak awal.

### Test Fixtures (Setup dan Cleanup)

*Test Fixtures* merujuk pada kebutuhan untuk menyiapkan kondisi awal (*setup*) dan membersihkan lingkungan (*cleanup*) yang diperlukan untuk menjalankan satu atau sekelompok tes.

Banyak *framework* menyediakan fungsi otomatis untuk ini (misalnya, di Python *unittest*):

* `setUp()`: Dijalankan sebelum setiap metode tes dieksekusi.
* `tearDown()`: Dijalankan setelah setiap metode tes selesai, bahkan jika terjadi *error*.

---

## Contoh Penerapan Konsep

Dalam praktiknya, unit testing adalah kode yang mengimpor dan menguji kode lain.

* Jika Anda menguji kelas `ShoppingCart` menggunakan **Pytest**, file tes Anda akan mengimpor `ShoppingCart` dan mencakup fungsi-fungsi seperti `test_add_item` (memverifikasi penambahan item) atau `test_add_overflow` (memastikan aplikasi menangani keranjang yang penuh).
* Jika Anda menguji kelas `BankAccount` dengan **JUnit 5**, Anda akan memiliki metode seperti `@Test testDeposit` (memastikan saldo bertambah) dan `@Test testWithdrawInsufficientFunds` (memastikan pengecualian *exception* dilempar jika saldo tidak memadai).

---